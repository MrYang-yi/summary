# 一、JVM

## 内存模型

### 线程公有

#### 堆

几乎所有的对象实例及数组都在堆上分配，也可能出现栈上分配，经过逃逸分析可能出现标量替换等手段

##### 逃逸分析

1. 栈上分配：确定一个对象不会逃逸到线程外
2. 标量替换：确定一个对象不会被外部方法引用，并且标量可替换，简单举例 类A属性中有类B的对象
3. 同步消除（锁消除）:变量不会逃出线程，无法被其他线程访问，读写不会有竞争，同步措施就会消除

#### 方法区

1. JDK6: 类型信息、域信息、方法信息、JIT代码缓存、静态变量、运行时常量池（包含字符串常量池）
2. JDK7: 静态变量和字符串常量池转移到堆
3. JDK8: 改名为元空间，JDK8以前内存由JVM管理，JDK8由本机内存限制

### 线程私有

#### Java虚拟机栈

为Java方法服务，会存放栈帧，一个栈帧，代表一个方法

##### 栈帧

![image-20221223003443104](/Users/yangzibiao/Downloads/project/idea/summary/pictures/image-20221223003443104.png)



#### 本地方法栈

为本地的Native方法服务

#### 程序计数器

线程执行字节码的行号指示器，为保证线程切换后，能恢复到正确的执行位置

# 二、类加载机制

![image-20221225152838076](/Users/yangzibiao/Downloads/project/idea/summary/pictures/image-20221225152838076.png)

## 类加载过程

1 加载:通过全限定名来加载生成class对象到内存中

2 验证:验证class文件，包括文件格式校验，元数据验证，字节码校验，符号引用验证等

3 准备:为类变量分配内存，并设置初始值0，不包含static final ,在编译期就分配了，不会为实例变量分配初始化，类变量在JDK7以前在方法区,JDK7以后在堆

4 解析:常量池中的符号引用转为直接引用（符号引用就是class文件中的CONSTANT_Class_info，CONSTANT_Field_info，CONSTANT_Method_info等类型的常量）

5 初始化:执行类构造器<clinit>的过程	

6 使用

7 卸载

## 双亲委派模型

### 定义

当收到类的加载请求时，不会自己去加载，请求委派给父类加载器依次向上委托，当父类加载器无法加载，才会自己尝试加载

### 优点

1 避免类被重复加载 

2 避免核心API被篡改 ，例如建一个java.lang包，建一个String类，JVM会用双亲委派模型加载最顶层的启动类(引导类加载器,也被称为沙箱安全机制)

## 类加载器

![image-20221228012738463](/Users/yangzibiao/Downloads/project/idea/summary/pictures/image-20221228012738463.png)

### 启动类加载器

加载JAVA_HOME/lib目录下java虚拟机能够识别的的jar包，名字不符合不能够加载

### 扩展类加载器

由ExtClassLoader实现的，它负责加载JAVA_HOME/lib/ext目录中jar包

### 应用程序类加载器

由AppClassLoader实现的，负责加载用户路径ClassPath上的所有类库

### 自定义加载器

继承 java.lang.classLoader 重写findclass方法

#### 优点

1.隔离加载类

2.修改类加载方式

3.扩展加载源

4.防止源码泄漏

## 破坏双亲委派模型

1 JDK1.2之前，双亲委派机制还未发布，出现loadclass()方法，也就是双亲委派的具体实现逻辑，可能被子类覆盖，解决:在ClassLoader中添加一个新的protected findclass()方法，尽可能重写它

2.被父类加载器加载，又要调回用户代码，例如JNDI,解决:添加一个线程上下文加载器

3.代码热替换，模块热部署，将模块与加载器一起换掉，例如OSGI(open service gateway initiative),动态模型系统，实现模块化热部署的关键是它自定义的类加载机制的实现，每一个程序模块都有自己的类加载器，当需要更换模块时，将模块与加载器一起换掉

## 引申

### 为什么tomcat会打破双亲委派机制

1.每个WebApp可能有不同类库，若直接加载最顶端的父类加载器，可能会导致冲突

2.WebAppClassLoader和JasperClassLoader（在WebAppClassLoader下面的一个结点）会自己加载，加载不到，再传给CommonClassLoader走双亲委派机制

![image-20221228020514895](/Users/yangzibiao/Downloads/project/idea/summary/pictures/image-20221228020514895.png)
举例：我们是可以把war包放到tomcat的webapp下，这意味着一个tomcat可以运行多个Web应用程序，那假设现在有两个Web应用程序，它们都有一个类，叫做User，并且它们的类全限定名都一样，比如都是com.yyy.User。但是他们的具体实现是不一样的，Tomcat给每个 Web 应用创建一个类加载器实例（WebAppClassLoader），该加载器重写了loadClass方法，优先加载当前应用目录下的类，如果当前找不到了，才一层一层往上找，这也是破坏了双亲委派机制。